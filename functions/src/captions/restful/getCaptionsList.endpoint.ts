import * as functions from 'firebase-functions';
import { Get } from 'firebase-backend';
import { Request, Response } from 'express';
import { decode } from 'urlencode';
import { URLSearchParams } from 'url';
import { context, Response as FetchResponse } from 'fetch-h2';
const { fetch } = context({
  httpProtocol: 'http2',
});

/**
 * Create a caption interface object
 */
interface Caption {
  baseUrl: string; // the URL to the caption
  query: string; // the query string on the baseUrl
  lang: string; // the language code for the track
  kind: 'asr' | 'standard'; // whether or not the track is autogenerated
  name: string; // the English readable name of the caption track
}

/**
 * An interface for the possible translation languages.
 */
interface TLang {
  lang: string; // the language code
  name: string; // the Simple English language name
}

/**
 * Create a response object for the CaptionsList
 */
interface CaptionsList {
  videoTitle: string;
  captions: Caption[];
  translation_langs: TLang[];
}

export default new Get(async (req: Request, res: Response) => {
  try {
    let captionsList = await getListOfVideoCaptions(req);
    return captionsList;
  } catch (error) {
    return respondWithError(res, error);
  }
});

async function getListOfVideoCaptions(req: Request): Promise<CaptionsList> {
  const { videoId } = getValidDataFromRequest(req);
  const videoInfo = await getVideoInfo(videoId);
  const captionsList = getCaptionsFromVideoInfo(videoInfo);
  return captionsList;
}

function getValidDataFromRequest(request: Request): { videoId: string } {
  const videoId = request.body.videoId;

  if (videoIdValid(videoId)) {
    return { videoId };
  }

  throw new functions.https.HttpsError(
    'invalid-argument',
    'YouTube Video ID required.'
  );
}

function videoIdValid(videoId: string): boolean {
  return !!videoId && videoId.length === 11;
}

async function getVideoInfo(videoId: string): Promise<string> {
  let videoInfoStream = await getVideoInfoReadableStream(videoId);
  let videoInfoBuffer = await getVideoInfoBufferFromStream(videoInfoStream);
  let videoInfo = decodeVideoInfoBuffer(videoInfoBuffer);
  return videoInfo;
}

async function getVideoInfoReadableStream(
  videoId: string
): Promise<NodeJS.ReadableStream> {
  try {
    const url = createEndpointUrl(videoId);
    let videoInfoResponse = await fetch(url);
    if (videoInfoResponse.ok) {
      return await videoInfoResponse.readable();
    }
    throw createFetchError(videoInfoResponse);
  } catch (error) {
    throw error;
  }
}

function createEndpointUrl(videoId: string): string {
  return `https://www.youtube.com/get_video_info?video_id=${videoId}&eurl=https%3A%2F%2Fyoutube.googleapis.com%2Fv%2Fonz2k4zoLjQ&html5=1&c=TVHTML5&cver=6.20180913`;
}

async function createFetchError(
  response: FetchResponse
): Promise<{ code: number; message: string }> {
  return { code: response.status, message: await response.json() };
}

async function getVideoInfoBufferFromStream(
  stream: NodeJS.ReadableStream
): Promise<Buffer> {
  try {
    return await getDataFromStream(stream);
  } catch (error) {
    throw { code: 500, message: "Couldn't get the YouTube Video info." };
  }
}

function getDataFromStream(stream: NodeJS.ReadableStream): Promise<any> {
  stream.setEncoding('utf-8');
  return createPromiseFromStream(stream);
}

function createPromiseFromStream(stream: NodeJS.ReadableStream): Promise<any> {
  return new Promise((resolve, reject) => {
    let data = '';
    stream.on('data', (chunk) => (data += chunk));
    stream.on('end', () => resolve(data));
    stream.on('error', (error) => reject(error));
  });
}

function decodeVideoInfoBuffer(buffer: Buffer): string {
  const urlEncoded = buffer.toString();
  const videoInfo = decode(urlEncoded);
  return videoInfo;
}

function getCaptionsFromVideoInfo(videoInfo: string): CaptionsList {
  const playerResponse = getPlayerResponseFromInfo(videoInfo);
  const videoDetails = getVideoDetailsFromPlayerResponse(playerResponse);
  const captions = getCaptionsFromVideoDetails(videoDetails);
  const captionsList = createCaptionsList(captions, videoDetails);
  return captionsList;
}

function getPlayerResponseFromInfo(videoInfo: string): any {
  const playerResponse = findPlayerResponseInUrlParams(videoInfo);
  if (playerResponse) {
    return JSON.parse(playerResponse);
  }
  throw { code: 404, message: "The YouTube video doesn't exist." };
}

function findPlayerResponseInUrlParams(videoInfo: string): any {
  const urlParams = new URLSearchParams(videoInfo);
  const playerResponse = urlParams.get('player_response');
  return playerResponse;
}

function getVideoDetailsFromPlayerResponse(playerResponse: any): any {
  let videoDetails = playerResponse.videoDetails;
  if (videoDetails) {
    return videoDetails;
  }
  throw { code: 404, message: "The YouTube video doesn't exist." };
}

function getCaptionsFromVideoDetails(videoDetails: any): any {
  let captions = videoDetails.captions;
  if (captions) {
    return captions;
  }
  throw {
    code: 404,
    message:
      'Unfortunately, this video has no captions to generate a transcript from.',
  };
}

function createCaptionsList(
  captionsObject: any,
  videoDetails: any
): CaptionsList {
  try {
    const videoTitle = getVideoTitle(videoDetails);
    const translation_langs = getTranslationLanguages(captionsObject);
    const captions = createCaptions(captionsObject);
    return { videoTitle, captions, translation_langs };
  } catch (error) {
    throw {
      code: 500,
      message: 'Could not create list of caption tracks.',
      context: error,
    };
  }
}

function getVideoTitle(videoDetails: any): string {
  return videoDetails.title;
}

function getTranslationLanguages(captionsObject: any): TLang[] {
  const translationLanguages = getAvailableLanguages(captionsObject);
  let tlangs: TLang[] = [];

  if (canCreateTlangs(translationLanguages)) {
    translationLanguages.forEach((translation: any) => {
      const tlang: TLang = {
        lang: translation.languageCode,
        name: translation.languageName.simpleText,
      };
      tlangs.push(tlang);
    });
  }
  return tlangs;
}

function getAvailableLanguages(captionsObject: any): any[] {
  return captionsObject.playerCaptionsTracklistRenderer.translationLanguages;
}

function canCreateTlangs(translationLanguages: any[]): boolean {
  return !!translationLanguages && translationLanguages.length > 0;
}

function createCaptions(captionsObject: any): Caption[] {
  const captionTracks = getCaptionTracks(captionsObject);
  let captions: Caption[] = [];
  if (canCreateCaptions(captionTracks)) {
    captionTracks.forEach((track: any) => {
      const caption: Caption = {
        lang: track.languageCode,
        baseUrl: track.baseUrl,
        query: track.baseUrl.split('?')[1],
        name: track.name.simpleText,
        kind: track.kind === 'asr' ? 'asr' : 'standard',
      };

      captions.push(caption);
    });
  }
  return captions;
}

function getCaptionTracks(captionsObject: any): any[] {
  return captionsObject.playerCaptionsTracklistRenderer.captionTracks;
}

function canCreateCaptions(captionTracks: any[]): boolean {
  return !!captionTracks && captionTracks.length > 0;
}

function respondWithError(res: Response, error: any): Response {
  logErrorToConsole(error);
  if (error.code) {
    return res.status(error.code).send(error.message);
  }
  return res.status(500).send(error);
}

function logErrorToConsole(error: any): void {
  console.error(error);
}
