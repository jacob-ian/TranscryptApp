import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { environment } from 'src/environments/environment';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

const GET_CAPTION_LIST_URL = '/captions-api/getCaptionsList';
const GET_CAPTION_TRACK_URL = '/captions-api/getCaptionTrack';

/**
 * Create a caption interface object
 */
interface Caption {
  baseUrl: string; // the URL to the caption
  query: string;
  lang: string; // the language code for the track
  kind: 'asr' | 'standard'; // whether or not the track is autogenerated
  name: string; // the English readable name of the caption track
}

/**
 * An interface for the possible translation languages.
 */
interface TLangs {
  lang: string; // the language code
  name: string; // the Simple English language name
}

/**
 * Create a response object for the CaptionsList
 */
export interface CaptionsList {
  videoTitle: string;
  captions: Caption[];
  translation_langs: TLangs[];
}

/**
 * The output object of the getTranscript method
 */
interface Transcripts {
  transcriptNoTime: string; // an HTML string without timestamps
  transcriptWithTime: string; // an HTML string with timestamps
}

@Injectable({
  providedIn: 'root',
})
export class TranscryptService {
  private baseApiUrl: string;

  constructor(private http: HttpClient) {
    this.baseApiUrl = environment.baseApiUrl;
  }

  public getCaptionsList(videoId: string): Observable<CaptionsList> {
    return this.get(GET_CAPTION_LIST_URL, { videoId });
  }

  private get(
    urlExtension: string,
    params: { [param: string]: string | string[] }
  ): Observable<any> {
    return this.http.get(`${this.baseApiUrl}${urlExtension}`, { params });
  }

  public getTranscript(
    encodedBaseUrl: string,
    translationLanguage: string
  ): Observable<Transcripts> {
    return this.get(GET_CAPTION_TRACK_URL, {}).pipe(
      map((captionTrack) => {
        return this.formatCaptionTrack(captionTrack);
      })
    );
  }

  private formatCaptionTrack(captionTrack: any): Transcripts {
    try {
      let transcriptNoTimestamps = this.formatTranscript(captionTrack, false);
      let transcriptWithTimestamps = this.formatTranscript(captionTrack, true);
      return {
        transcriptWithTime: transcriptWithTimestamps,
        transcriptNoTime: transcriptNoTimestamps,
      };
    } catch (error) {
      throw { message: "Couldn't format the transcript." };
    }
  }

  private formatTranscript(captionTrack: any, timestamps: boolean): string {
    // Create an output line
    var outputHtml = '';

    // Check for timestamps
    if (timestamps) {
      const length = captionTrack.text.length;

      // Find the bigget value of time in the array to determine the timestamp format
      const maxTime = captionTrack.text[length - 1]['$'].start;

      // Check if there are any hours
      const maxHours = Math.floor(maxTime / 3600);

      // Create the time format depending on the time range
      var timeFormat: 'hours' | 'minutes' = 'minutes';

      // Check if we are in the hours range
      if (maxHours !== 0) {
        timeFormat = 'hours';
      }

      // Iterate over the transcript array items
      captionTrack.text.forEach((line: any) => {
        // Convert the time to something useful
        const time = line['$'].start;

        // Depending on the time format required, create a timestamp
        if (timeFormat === 'minutes') {
          // Calculate the number of minutes
          var hours = '';
          var minutes = `${Math.floor(time / 60)}:`;
          var seconds = `${Math.floor(time % 60)}`;

          if (minutes.length === 2) {
            minutes = `0${minutes}`;
          }

          if (seconds.length === 1) {
            seconds = `0${seconds}`;
          }
        } else {
          // Create a value to hold all the seconds
          var allTime = time;

          // Calculate the digits
          var hours = `${Math.floor(allTime / 3600)}:`;
          allTime %= 3600;
          var minutes = `${Math.floor(allTime / 60)}:`;
          var seconds = `${Math.floor(allTime % 60)}`;

          // Create the strings
          if (hours.length === 2) {
            hours = `0${hours}`;
          }

          if (minutes.length === 2) {
            minutes = `0${minutes}`;
          }

          if (seconds.length === 1) {
            seconds = `0${seconds}`;
          }
        }

        // Create the timestamp
        var stamp = `${hours}${minutes}${seconds}`;

        // Get the line
        outputHtml = `${outputHtml}<p><b>${stamp}: </b>${line['_']}</p>`;
      });
    } else {
      // Iterate over the transcript array items
      captionTrack.text.forEach((line: string) => {
        // Get the line
        outputHtml = `${outputHtml}<p>${line['_']}</p>`;
      });
    }

    // Return the output HTML string
    return outputHtml;
  }

  public async getStripeClientSecret(
    amount: number,
    currency: string
  ): Promise<string> {
    try {
      let paymentIntent = await this.post('/payments-api/createPaymentIntent', {
        amount,
        currency,
      }).toPromise();
      return paymentIntent.client_secret;
    } catch (error) {
      throw {
        message:
          "Couldn't create Stripe Payment intent. Please try again later.",
      };
    }
  }

  private post(urlExtension: string, body: any): Observable<any> {
    return this.http.post(`${this.baseApiUrl}${urlExtension}`, body);
  }
}
